<!DOCTYPE html>
<html>
<head>
  <title>Hand Tracking Sparkles</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { width: 100%; height: 100%; display: block; position: absolute; top: 0; left: 0; }
    #videoElement { position: absolute; top: 0; left: 0; width: 320px; height: 240px; display: none; }
  </style>
</head>
<body>
  <video id="videoElement" autoplay playsinline></video>
  <canvas id="threeCanvas"></canvas>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.module.js';
    import {
      FilesetResolver,
      HandLandmarker,
      DrawingUtils
    } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest";

    let scene, camera, renderer, particles, sparkles = null, gestureIndicator = null;

    init();
    animate();

    async function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 0, 5);

      renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('threeCanvas'), alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x000000, 1);
      renderer.sortObjects = false;

      window.addEventListener('resize', onWindowResize, false);

      await setupMediaPipe();
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }

    async function setupMediaPipe() {
      const video = document.getElementById("videoElement");

      // Camera setup
      const constraints = {
        video: { facingMode: { exact: "environment" } },
      };
      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      video.srcObject = stream;

      const filesetResolver = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"
      );
      const handLandmarker = await HandLandmarker.createFromOptions(
        filesetResolver,
        {
          baseOptions: {
            modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
            delegate: "GPU",
          },
          numHands: 1,
          runningMode: "VIDEO",
        }
      );

      video.onloadedmetadata = () => {
        detectHands();
      };

      async function detectHands() {
        if (video.readyState >= 2) {
          const results = handLandmarker.detectForVideo(video, Date.now());

          if (results.landmarks && results.landmarks[0]) {
            const landmarks = results.landmarks[0];
            const isLifted = checkIndexFingerLift(landmarks);

            const indexTip = landmarks[8];
            const threeDIndexTip = new THREE.Vector3(
              (indexTip.x - 0.5) * 4,
              -(indexTip.y - 0.5) * 4,
              -indexTip.z * 5
            );

            console.log("isLifted:", isLifted);
            console.log("threeDIndexTip:", threeDIndexTip);
            console.log("sparkles:", sparkles);

            if (isLifted && !sparkles) {
              sparkles = createSparkles(threeDIndexTip);
            }
            if (!isLifted && sparkles) {
              removeSparkles();
            }

            if (sparkles) {
              updateSparkles();
            }

            if (isLifted && !gestureIndicator) {
              const geometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
              const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
              gestureIndicator = new THREE.Mesh(geometry, material);
              scene.add(gestureIndicator);
            } else if (!isLifted && gestureIndicator) {
              scene.remove(gestureIndicator);
              gestureIndicator = null;
            }

          }
        }
        requestAnimationFrame(detectHands);
      }
    }

    function checkIndexFingerLift(landmarks) {
      if (!landmarks || landmarks.length === 0) return false;

      const indexTipY = landmarks[8].y;
      const indexBaseY = landmarks[5].y;
      const threshold = 0.05;
      const difference = indexBaseY - indexTipY;
      console.log("Difference:", difference);

      return difference > threshold;
    }

    function createSparkles(position) {
      position = new THREE.Vector3(0, 0, -3);
      const geometry = new THREE.BufferGeometry();
      const particlesCount = 100;
      const positions = new Float32Array(particlesCount * 3);
      const colors = new Float32Array(particlesCount * 3);
      const sizes = new Float32Array(particlesCount);

      for (let i = 0; i < particlesCount; i++) {
        const x = position.x + (Math.random() - 0.5) * 0.2;
        const y = position.y + (Math.random() - 0.5) * 0.2;
        const z = position.z + (Math.random() - 0.5) * 0.2;

        positions[i * 3] = x;
        positions[i * 3 + 1
